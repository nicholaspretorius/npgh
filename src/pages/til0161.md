---
title: "Terraform, Kubernetes and EKS Command Cheat Sheet."
id: "TIL 0161"
date: "2020-04-06"
---

Below are some useful commands when working with Terraform, KubeOne, Kubernetes and EKS:

### Terraform

Note that the [default] AWS credentials are used from `~/aws/credentials`: 

`AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` need to be specified as environment variables in your Terminal. Instead of manually setting these in each Terminal session, you can add these to: 

`~/.bashrc`

Then, from the command line, run: 

`source ~/.bashrc` 

This will activate the latest vars for your Terminal. 

#### SSH

You need an SSH key to successfully run the Terraform commands. 

Take a look [here](https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent) for background on how to add your SSH key.

* Start SSH agent in background: 

`eval "$(ssh-agent -s)"`


* Add SSH key to ssh-agent and store passphrase in keychain:

`ssh-add -K ~/.ssh/id_rsa`

Commands to run in order to setup KubeOne on AWS infrastructure via Terraform: 

* `terraform version` check Terraform version
* `kubeone version` check KubeOne version
* `cd/terraform && terraform init` Initialise Terraform from folder containing Terraform files
* `terraform plan` shows what Terraform will setup for you
* `terraform plan -out plan` outputs a non-human readable Terraform plan, in order to see what the plan outputs, run the following command: 
* `terraform show -json plan`
* `terraform apply` Terraform will create the infrastructure required
* `terraform output -json > tf.json` Output Terraform config
* `kubeone reset ./terraform/config.yaml --tfjson ./terraform/tf.json` reset k8s according to Terraform (see notes below on how to setup the k8s on the TF infrastructure)
* `terraform destroy` destroy all terraform infrastructure setup by Terraform

### Kubernetes, KubeOne

* `kubectl version` check k8s version
* `kubeone install config.yaml --tfjson tf.json` configure k8s cluster according to Terraform (as defined above)
* `export KUBECONFIG=$PWD/projectname-kubeconfig` export kubeconfig to env vars
* `kubectl get secrets` display secrets
* `kubectl create secret generic env-secret --from-literal=DB_USER='dbusernamehere' --from-literal=DB_PASS='dbpasshere' --from-literal=JWT_SECRET='jwtsecrethere'` create env secrets
* `kubectl create secret generic aws-secret --from-literal=aws_access_key_id='awssecretkeyhere' --from-literal=aws_secret_access_key='awssecretaccesskeyhere'` create AWS secrets
* `kubectl delete secrets env-secret.yaml` delete secret
* `kubectl cluster-info` get k8s cluster info
* `kubectl config view` view k8s config info
* `kubectl get nodes` view k8s nodes
* `kubectl get service client -o wide` view k8s services

### EKS (Elastic Kubernetes Service)

* `eksctl create cluster -f cluster.yaml` create cluster on AWS via EKS
* `eksctl create cluster --name projectname-here`
* `eksctl utils update-cluster-logging --region=eu-west-1 --cluster=projectname-here`
* `eksctl create cluster --name=projectname-here --nodes=3 --managed --alb-ingress-access --region=${AWS_REGION}`
* `eksctl delete cluster --name=name-here`

### k8s

In order to create your configmaps, deployments and services, run the following: 

* `kubectl apply -f ./path/to/k8sfiles/env-configmap.yaml` create configmap
* `kubectl get configmaps`
* `kubectl apply -f ./path/to/k8sfiles/appname.deployment.yaml` create deployment
* `kubectl get deployments`
* `kubectl get pods`
* `kubectl describe pods podnamehere`
* `kubectl logs podname-7bdc944cdb-kn9wv`
* `kubectl apply -f ./path/to/k8sfiles/appname.service.yaml`
* `kubectl convert -f ./path/to/k8sfiles/appname.deployment.yaml --output-version apps/v1` change apiVersion
* `kubectl get services`
* `kubectl get pods -o wide`
* `kubectl get pods podname-7bdc944cdb-s7d4n --template='{{(index (index .spec.containers 0).ports 0).containerPort}}{{"\n"}}'` get container port
* `kubectl get rs` get replica sets
* `kubectl port-forward services/servicename 8080:8080`
* `kubectl port-forward services/servicename 8100:8100`
* `kubectl port-forward services/servicename 8080:8080 &` to run in background, then press `fg` to get it back into foreground
* `kubectl get machinedeployments -n kube-system`
* `kubectl scale machinedeployment/projectname-eu-west-1a -n kube-system --replicas=2` scale up
* `kubectl scale machinedeployment/projectname-eu-west-1a -n kube-system --replicas=0` scale down
* `kubectl delete -f ./path/to/k8sfiles/appname.service.yaml`
* `kubectl delete -f ./path/to/k8sfiles/appname.deployment.yaml`

Useful commands from k8s Tutorials:

* `kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2` rolling update
* `kubectl describe services/kubernetes-bootcamp`
* `export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}'`
* `echo NODE_PORT=$NODE_PORT`
* `curl $(minikube ip):$NODE_PORT`
* `kubectl rollout status deployments/kubernetes-bootcamp`
* `kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v10` fetch image that does not exist...
* `kubectl get deployments` see not all are ready...
* `kubectl get pods` will show new pods erroring...
* `kubectl rollout undo deployments/kubernetes-bootcamp` undo rollout... 
* `kubectl get pods` back to normal, only running pods
* `kubectl expose deployment/kubernetes-bootcamp --type="NodePort" --port 8080` expose service 
* `kubectl get services` view service details
* `kubectl describe services/kubernetes-bootcamp` see further details
* `export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')`
* `echo NODE_PORT=$NODE_PORT`
* `curl $(minikube ip):$NODE_PORT`
* `kubectl describe deployment` describe deployment, take not of the "label" field, which is run=kubernetes-bootcamp
* `kubectl get pods -l run=kubernetes-bootcamp` get pods with that label (-l)
* `kubectl get services -l run=kubernetes-bootcamp` can use for services too
* `export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')` store pod name
* `echo Name of the Pod: $POD_NAME` display pod name
* `kubectl label pod $POD_NAME app=v1` give pod a new label
* `kubectl describe pods $POD_NAME` see pod has nee label
* `kubectl get pods -l app=v1` query with new label
* `kubectl delete service -l run=kubernetes-bootcamp` delete service
* `kubectl get services` see NodePort service no longer available
* `curl $(minikube ip):$NODE_PORT` failed to connect (since it no longer exists)
* `kubectl exec -ti $POD_NAME curl localhost:8080` confirm app is still running on internal cluster

Further notes on k8s:

When you see values "port" and "targetPort". "port" is the port on the external IP, "targetPort" is the port on the container. 

`port-forward` is only a means of debugging, it is not a practical means of making containers available. 
